#
# zsh rc file for Uli "youam" Martens <uli@youam.net>
#

#
# path settings
#

# if my home has a bin/ directory, I want it to be the first entry in my $PATH
if [ -d "$HOME/bin" ]; then
	export PATH="$HOME/bin:$PATH"
fi

if [ -e "$HOME/.alias" ]; then
	source "$HOME/.alias"
fi

# add private path for latex files
#   trailing colon -> append standard search path to TEXINPUTS
#   trailing double slash -> search directory recursively
if [ -e "$HOME/.tex" ]; then
	export TEXINPUTS="$HOME/.tex//:"
fi

#
# keybinding settings
#

# select VI keybindings
bindkey -v

bindkey "^R" history-incremental-search-backward
bindkey "^P" history-beginning-search-backward


#
# prompt settings
#

PROMPT=$'%0(?..%{\033[31m%}%B%?%b:)%(!.%{\033[31m%}%B.%{\033[34m%}%B%n@)%m%b:%B%30<...<%~%b%(!.#.$) '
PROMPT=$'%0(?..%{\033[31m%}%B%?%b:)%(!.%{\033[31m%}%B.%{\033[34m%}%B%n@)%m%b:%B%30<...<%~%b%(1v.%F{green}%1v%f.)%(!.#.$) '
#        ^^^^^^^^^^^^^^^^^^^^^^^^^^
# print the return status of the last executed command if it is not null

#                                  ^^^^^^^^^^^^^^^^^^^                 ^                    ^^^^^ ^
# if we're root, print the hostname bold red, suffix the prompt with a hash
# mark
#                                  ^^^^              ^^^^^^^^^^^^^^^^^^^                    ^^^ ^^^
# if we're not root, prepend the hostname with the user name, printed in bold
# blue, suffix the prompt with a dolar sign.

#                                                                              ^^^^^^^^^^^^^^^^^^^^^
# limit the rest of the prompt to a total of 30 characters, of which the first
# chars will be replaced by '...'

fpath+=(~/.zsh/functions)

# this is taken from grml's zshrc
function zrcautoload() {
    emulate -L zsh
    setopt extended_glob
    local fdir ffile
    local -i ffound

    ffile=$1
    (( found = 0 )) 
    for fdir in ${fpath} ; do 
        [[ -e ${fdir}/${ffile} ]] && (( ffound = 1 )) 
    done 

    (( ffound == 0 )) && return 1
    if [[ $ZSH_VERSION == 3.1.<6-> || $ZSH_VERSION == <4->* ]] ; then 
        autoload -U ${ffile} || return 1
    else 
        autoload ${ffile} || return 1
    fi
    return 0
}

zrcautoload vcs_info || vcs_info() {return 1}

precmd_vcs_info() {
   psvar=()
   vcs_info
   [[ -n $vcs_info_msg_0_ ]] && psvar[1]="$vcs_info_msg_0_"
}



#
# screen colaboration
#

# set the screen window title to the current command
preexec () {
	if [[ "$TERM" == "screen" ]]; then
		# needs: setopt extended_glob
		local CMD=${1[(wr)^(*=*|sudo|man|vi|-*)]}
		echo -ne "\ek$CMD\e\\"
	fi
}

# reset the screen window titel to "zsh"
precmd_screen_title () {
	 if [[ "$TERM" == "screen" ]]; then
		 echo -ne "\ekzsh\e\\"
	 fi
}

precmd () {
	precmd_vcs_info
	precmd_screen_title
}

#
# command line history
#

HISTFILE=~/.histfile
HISTSIZE=100000
SAVEHIST=100000

# append to the history file when executing commands, not on exit
setopt INC_APPEND_HISTORY

# reload the history file before adding to it
setopt SHARE_HISTORY

setopt hist_find_no_dups hist_ignore_dups
#
# shell features
#

# use extended globbing, (^ for inverted matches etc)
setopt EXTENDED_GLOB

###############################################################################
###############################################################################
###############################################################################
###############################################################################
#
# beep on error in zle
setopt beep

# notify background job changes at once, don't wait for prompt
setopt notify

# Wait for KEYTIMEOUT ms if the input could be the prefix to some longer command
#KEYTIMEOUT=40



# The following lines were added by compinstall

zstyle ':completion:*' completer _complete
zstyle ':completion:*' completions 1
zstyle ':completion:*' glob 1
zstyle ':completion:*' substitute 1
zstyle :compinstall filename '/home/youam/.zshrc'

autoload -Uz compinit
compinit

setopt auto_pushd

unsetopt autocd nomatch

if [ -d $HOME/.perl ]; then
	export PERL5LIB=$HOME/.perl
fi

# precmd() {
#	local escape colno lineno
#	IFS='[;' read -s -d R escape\?$'\e[6n' lineno colno
#	(( colno > 1 )) && echo ''
# }


export EDITOR=vim
