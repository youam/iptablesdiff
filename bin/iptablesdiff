#!/usr/bin/perl

# iptablesdiff -- compare two iptables-save rulesets
# call as   $0  ruleset1 ruleset2
# depends: libyaml-syck-perl libalgorithm-diff-perl

# Copyright (c) 2010-2014 Uli Martens <uli@youam.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use YAML::Syck;
use Algorithm::Diff;

# this is a list of iptables rules which are omitted by iptables-save if
# they're unchanged because they're probably not even loaded
my $implicit_rules = q{
*nat
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
*filter
:FORWARD ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
};

sub canonicalize_service {
	my $service = shift;

	my $SERVICE = {
		ssh => 22,
		smtp => 25,
		domain => 53,
		http => 80,
		pop3 =>  110,
		ntp => 123,
		imap2 => 143,
		https => 443,
		bgp => 179,
		imaps => 993,
		pop3s => 995,
		nrpe => 5666,
	};

	return $SERVICE->{$service} if defined $SERVICE->{$service};

	return $service;
}
sub canonicalize_services {
	my $srv = shift;

	my @srvs = sort { $a <=> $b } map { canonicalize_service( $_ ) } split /,/, $srv;

	return join ( ",", @srvs );
}

sub normalize_iptablesrule {
	my $_ = shift;

	# regex snippets
	my $dev = '[a-z0-9_]+';
	my $ip  = '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+';
	my $net = $ip.'/[0-9]+';
	my $port = '[0-9]+|[0-9]+:[0-9]+';

	s/$/ /;

	s/ --source / -s /;
	s/ --destination / -d /;
	s/ --out-interface / -o /;
	s/ --in-interface / -i /;
	s/ --jump / -j /;
	s/ --protocol / -p /;
	s/ --match / -m /g;
	s# --state ESTABLISHED,RELATED # --state RELATED,ESTABLISHED #;
	s/ -m state -p tcp / -p tcp -m state /;
	s/ --destination-ports / --dports /;

	s#-d ($ip) #-d $1/32 #;
	s#-s ($ip) #-s $1/32 #;

	s# --comment ([a-z0-9_-]+) # --comment "$1" #;

	# FIXME this should be done for all services by looking up getent info
	if ( m/ --dport ([a-zA-Z0-9]+) / ) {
		my $o = $1;
		my $r = canonicalize_service( $o );
		s/ --dport $o / --dport $r /;
	}
	if ( m/ --dports ([a-zA-Z0-9,]+) / ) {
		my $o = $1;
		my $r = canonicalize_services( $o );
		s/ --dports $o / --dports $r /;
	}

	s# --limit ([0-9]+)/s # --limit $1/sec #;

	# set default values where optional and omitted
	s/ -j REJECT\s*$/ -j REJECT --reject-with icmp-port-unreachable/;

	# this normalizes the wrong way, but it's better readable this way
	s/ -m icmp --icmp-type 8 / --icmp-type echo-request /;

	s# -p (tcp|udp|icmp)(( .*)?)-m \1 # -p $1$2 #;

	# fixup misc order stuff
	s# -j SNAT (.*) --to-source # $1 -j SNAT --to-source #;
	s# -o ($dev) -d ($ip) # -d $2 -o $1 #;
	s# -i ($dev) -s ($net) -d ($net) # -s $2 -d $3 -i $1 #;
	s# -i ($dev)(( .*)?) -s ($net) # -s $4 -i $1$2 #;
	s# -p (tcp|udp|icmp) --dport ($port)(( -s $net)?( -d $net)?) #$3 -p $1 --dport $2 #;
	s# -i ($dev) -p (tcp|udp) -d ($net) # -d $3 -i $1 -p $2 #;
	s# -p (tcp|udp|icmp) -s ($net) -d ($net) # -s $2 -d $3 -p $1 #;
	s# -p (tcp|udp|icmp) -d ($net) # -d $2 -p $1 #;
	s# -p (tcp|udp|icmp) -s ($net) -i ($dev) -o ($dev) # -s $2 -i $3 -o $4 -p $1 #;
	s# -i ($dev) -o ($dev) -d ($net) # -d $3 -i $1 -o $2 #;

	s# -o ($dev) -d ($net) # -d $2 -o $1 #;
	s# -i ($dev) -d ($net) # -d $2 -i $1 #;
	s# --dport ($port) --sport ($port) # --sport $2 --dport $1 #;
	s# -p (tcp|udp|icmp) --dport ($port) -o ($dev) # -o $3 -p $1 --dport $2 #;
	s# -d ($net) -p (tcp|udp) --dport ($port) -s ($net) # -s $4 -d $1 -p $2 --dport $3 #;


	s# -p (tcp|udp) -s ($net) # -s $2 -p $1 #;
    s# -p (tcp|udp) -m state # -m state -p $1 #;

    s# -s 0/0 # #;
    s# -d 0/0 # #;

	s#  +# #;
	s# +$##;

	return $_;
}

sub parse_ruleset {
	my $file = shift;

	my @rules;
	push @rules, split( "\n", $implicit_rules );

	open my $FILE, '<', $file
		or die "$0: can't open file $file: $!";
	push @rules, <$FILE>;
	close $FILE;

	my $ruleset;
	my $table;
	for ( @rules ) {
		chomp;
		next if m/^#/;
		next if m/^COMMIT/;
		s/ *$//;
		next if m/^$/;

		$_ = normalize_iptablesrule( $_ );

		if ( m/^\*([a-zA-Z0-9_-]+)$/ ) {
			# this is a table
			$ruleset->{$1} = {} unless defined $ruleset->{$1};
			$table = $1;
			next;
		}
		if ( m/^:([a-zA-Z0-9_-]+) (ACCEPT|DROP|-) \[[0-9]+:[0-9]+\]$/ ) {
			my $chain = $1;
			my $policy = $2;
			$ruleset->{$table}->{$chain}->{policy}=$policy;
			$ruleset->{$table}->{$chain}->{rules} = [];
			next;
		}
		if ( m/^-A ([a-zA-Z0-9_-]+) (.*)$/ ) {
			my $chain = $1;
			my $rule  = $2;
			push @{$ruleset->{$table}->{$chain}->{rules}}, $rule;
			next;
		}
		print STDERR "ignored: $_";
	}
	return $ruleset;
}

sub compare_chains {
	my $table = shift;
	my $chain = shift;
	my $c1 = shift;
	my $c2 = shift;

	if ( defined $c1 and not defined $c2 ) {
		print "; iptables -t $table -X $chain\n";
		return;
	} elsif ( not defined $c1 and defined $c2 ) {
		print "; iptables -t $table -N $chain\n";
		$c1->{rules} = [];
	} elsif ( $c1->{policy} ne $c2->{policy} ) {
		print "; iptables -t $table -P $chain $c2->{policy}\n";
	}
	my $diff = Algorithm::Diff->new( $c1->{rules}, $c2->{rules} );
	my $same=1;
	while ( $diff->Next() ) {
		if ( !$diff->Same() ) {
			$same=0;
			last;
		}
	}
	$diff->Reset();
	if ( $same ) {
		#print "# rules are unchanged\n";
	} else {
		print "# rules diff for table $table, chain $chain\n";
		while(  $diff->Next()  ) {
			if ( $diff->Same() ) {
				print "  $_\n" for $diff->Items(1);
				next;
			}
			print "- $_\n"   for  $diff->Items(1);
			print "+ $_\n"   for  $diff->Items(2);
		}
		$diff->Reset();
		my $p = 1;
		while(  $diff->Next()  ) {
			if ( $diff->Same() ) {
				$p += scalar $diff->Items(1);
				next;
			}
			print "; iptables -t $table -D $chain $p # $_\n" for $diff->Items(1);
			print "; iptables -t $table -I $chain ",$p++," $_\n" for $diff->Items(2);
		}
	}
}

sub compare_tables {
	my $table = shift;
	my $t1 = shift;
	my $t2 = shift;

	my %all_chains;
	$all_chains{$_}++ for keys %{$t1};
	$all_chains{$_}++ for keys %{$t2};

	for my $chain ( sort keys %all_chains ) {
		compare_chains( $table, $chain, $t1->{$chain}, $t2->{$chain} );
	}
}

sub compare_rulesets {
	my $r1 = shift;
	my $r2 = shift;

	my %all_tables;
	$all_tables{$_}++ for keys %{$r1};
	$all_tables{$_}++ for keys %{$r2};

	for my $table ( sort keys %all_tables ) {
		compare_tables( $table, $r1->{$table}, $r2->{$table} );
	}
}

my $r1 = parse_ruleset( $ARGV[0] );
my $r2 = parse_ruleset( $ARGV[1] );

compare_rulesets( $r1, $r2 );
